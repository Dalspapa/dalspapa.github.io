# 🖥 리눅스 최소 설치 시 netstat, ifconfig 설치 방법

<br/>

## 💻 CentOS
---

### `sudo yum install net-tools`

<br/>

## 💻 Ubuntu
---

### `sudo apt-get install net-tools`

<br/>
<br/>

# netstat 명령어를 통한 네트워크 상태 확인 방법

<br/>

## 🌏 `netstat`
---

*네트워크 접속, 라우팅 테이블, 네트워크 인터페이스의 통계 정보를 보여주는 도구*

> **`netstat [옵션] [| grep 포트 번호 or 서비스 명]`**

<br/>

### 🔨 옵션
---

- **`-l`** (0**listen**) : 연결 가능한 상태
- **`-n`** (**number port**) : 포트 넘버
- **`-t`** (**tcp**) : tcp
- **`-u`** (**udp**) : udp
- **`-p`** : 프로그램 이름 / PID
- **`-a`** : 모두
- **`-i`** : 이더넷 카드별 정상/에러/드랍 송수신 패킷 수 확인
- **`-r`** : 라우팅 테이블
- **`-s`** : 네트워크 통계

<br/>

### 💪 자주 사용 하는 옵션
---

- **`netstat -nap`** : 연결을 기다리는 목록과 프로그램을 보여준다.

- **`netstat -an | grep 포트번호`** : 특정 포트가 사용 중에 있는지 확인. 

- **`netstat -nlpt`** : TCP listening 상태의 포트와 프로그램을 보여준다.

<br/>

### 🔎 netstat 상태 값
---

|State|Description|
|---|---|
|CLOSED|완전히 연결이 종료된 상태|
|CLOSING|흔하지 않으나 주로 확인 메시지가 전송 도중 유실된 상태|
|CLOSE_WAIT|TCP 연결이 상위 응용프로그램 레벨로부터 연결 종료를 기다리는 상태|
|ESTABLISHED|서버와 클라이언트 간에 세션 연결이 성립되어 통신이 이루어지고 있는 상태 (클라이언트가 서버의 SYN을 받아서 세션이 연결된 상태)|
|FIN_WAIT1|클라이언트가 서버에게 연결을 끊고자 요청하는 상태(FIN을 보낸 상태)|
|FIN_WAIT2|서버가 클라이언트로부터 연결 종료 응답을 기다리는 상태 (서버가 클라이언트로부터 최초로 FIN을 받은 후, 클라이언트에게 ACK를 주었을 때|
|LAST_ACK|호스트가 원격지 호스트의 연결 종료 요구 승인을 기다리는 상태 (서버가 클라이언트에게 FIN을 보냈을 때의 상태)|
|LISTEN|서버의 데몬이 떠 있어서 클라이언트의 접속 요청을 기다리고 있는 상태|
|SYN_SENT|클라이언트가 서버에게 연결을 요청한 상태
|SYN_RECEIVED|클라이언트가 서버에게 연결을 요청한 상태서버가 클라이언트로부터 접속 요구(SYN)을 받아 클라이언트에게 응답(SYN/ACK)하였지만, 아직 클라이언트에게 확인 메시지(ACK)는 받지 못한 상태|
|TIME_WAIT|연결은 종결되었지만 당분간 소켓을 열어 놓은 상태, 약 1분 정도이며 시간이 지나면 사라짐|
|UNKNOWN|소켓의 상태를 알 수 없음|

<br/>

> 📌
>
> 웹서버에 요청을 하고 연결을 끊어버리는 공격을 당하면 웹서버는 이에 대한 대기 상태로 남아있게 됨.
> 
> 웹서버의 자원이 무한대로 지원이 되지 않기 때문에 이런 상태가 늘어나게 되면 웹서버 자원 부족으로 인한 웹서비스 지연 및 기타 서비스들에 대한 자원 부족 문제로 hang 상태로 빠지게 되는 상황까지 이를 수 있음.
>
> 특히 동일 IP에 대한 유입이 과다한 상태인경우 해당 IP를 차단

<br/>
<br/>
<br/>

# 💾scp 명령어

<br/>

## ❓ SCP 란
---

*Secure Copy의 약자로 ssh 프로토콜을 기반으로 파일이나 디렉토리를 전송하거나 가져올 때 사용합니다.*

*당연히 네트워크 통신이 가능한 환경에서 22번 Port와 Identify File을 이용해 파일을 안전하게 송/수신할 수 있다.*

<br/>

## 🏳‍🌈 Flags (옵션)
---

- **r** : 디렉토리 및 하위 모든 파일을 복사
- **p** : 원본 속성값 복사
- **P**	: 포트 번호 지정 복사
- **c** : 압축하여 복사
- **v** : 복사 과정을 출력
- **a** : 아카이브 모드로 복사

<br/>

## 🖥 Local(로컬) → 💻 Remote(원격지)
---

📌 모든 명령어는 로컬 서버에서 입력합니다.

<br/>

### 단일 파일 전송

> **`scp [옵션] [파일명] [원격지 계정]@[원격지 IP]:[파일이 저장될 경로]`**
> 
> ex.) `scp -P 7789 test.zip eloquence@192.168.1.100:/home/eloquence`
> > 현재 경로의 test.zip 파일을 원격지(192.168.1.100, port : 7789) 서버의 /home/eloquence 경로로 전송한다.
​
<br/>

### 복수 파일 전송

> `scp [옵션] "[파일명①] [파일명②] [파일명③]" [원격지 계정]@[원격지 IP]:[파일이 저장될 경로]`
> 
> ex.) `scp "test1 test2" eloquence@192.168.1.100:/tmp`
> 
>> 현재 경로의 test1, test2 파일을 원격지(192.168.1.100, port : 22) 서버의 /tmp 경로로 전송한다.
>>
>> (기본적으로 -P 포트번호 옵션 미 입력시 Default Port Number는 22번이다)

<br/>

### 디렉토리 전송

> `scp [옵션] [디렉토리명] [원격지 계정]@[원격지 IP]:[파일이 저장될 경로]`
> 
> ex.) `scp -r /usr/sbin eloquence@192.168.1.100:/test`
>
> > /usr 하위에 있는 sbin 디렉토리를 원격지(192.168.1.100) 서버의 /test 경로로 전송한다.

<br/>
<br/>

## 💻 Remote(원격지) → 🖥 Local(로컬)
---

📌 모든 명령어는 로컬 서버에서 입력합니다.

<br/>

### 단일 파일 가져오기
> `scp [옵션] [원격지 계정]@[원격지 IP]:[파일명] [로컬 서버에 저장될 경로]`
> 
> ex. ) `scp eloquence@192.168.1.100:/etc/ssh/sshd_config /etc/ssh`
> 
> > 원격지 서버의 /etc/ssh/sshd_config 파일을 로컬 서버 /etc/ssh 경로로 가져온다.
​
<br/>

### 복수 파일 가져오기

> `scp [옵션] [원격지 계정]@[원격지 IP]:"[파일명①] [파일명②] [파일명③]" [로컬 서버에 저장될 경로]`
> 
> ex.) `scp eloquence@192.168.1.100:"/etc/test1 /etc/test2" /etc`
> 
> > 원격지 서버의 /etc/test1 파일과 /etc/test2 로컬 서버 /etc 경로로 가져온다.
​
​<br/>
​
### 디렉토리 가져오기

> `scp [옵션] [원격지 계정]@[원격지 IP]:[디렉토리명] [로컬 서버에 저장될 경로]`
> 
> ex.) `scp -r eloquence@192.168.1.100:/etc/ssh /home`
> 
> > 원격지 서버의 /etc/ssh 디렉토리를 로컬 서버 /home 경로로 가져온다.